---
stepsCompleted: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
inputDocuments:
  - _bmad-output/index.md
  - _bmad-output/project-overview.md
  - _bmad-output/architecture.md
  - _bmad-output/source-tree-analysis.md
  - _bmad-output/component-inventory.md
  - _bmad-output/development-guide.md
  - _bmad-output/deployment-guide.md
  - docs/index.md
  - docs/datastore-schema.md
  - docs/datastore_methods.md
  - docs/request-logs.md
  - docs/typecasting.md
  - docs/rql.md
  - src/DataStore/src/DataStore/Scheme/README.md
documentCounts:
  briefs: 0
  research: 0
  brainstorming: 0
  projectDocs: 14
workflowType: 'prd'
lastStep: 11
project_name: 'rollun-datastore'
user_name: 'Iliya'
date: '2025-12-22T19:14:20Z'
---

# Product Requirements Document - rollun-datastore

**Author:** Iliya
**Date:** 2025-12-22T19:14:20Z

## Executive Summary

Мы переписываем библиотеку rollun-datastore с нуля, используя DDD и Clean Architecture. Цель — сделать архитектуру устойчивой к изменениям, повысить тестируемость и устранить накопившиеся баги, которые появились из‑за устаревшего кода и постепенных «надстроек» за последние годы.

Проект будет выполнен поэтапно: сначала определяем доменные сущности и модель, затем описываем модули и интерфейсы, после чего создаем минимальный каркас (пустые файлы + интерфейсы). Далее на основе структуры пишем тесты и реализуем функциональность по модулям.

### What Makes This Special

Это не косметический рефакторинг, а полный **архитектурный перезапуск** с фокусом на долгосрочную расширяемость. Основная ценность — чистое модульное разделение и понятные доменные границы, которые дадут:
- проще добавлять новую функциональность,
- лучше изолировать изменения,
- упростить сопровождение и тестирование,
- устранить устаревшие решения, накопленные за 5 лет развития.

## Project Classification

**Technical Type:** developer_tool (PHP library)
**Domain:** general  
**Complexity:** low  
**Project Context:** Brownfield — переписываем существующую систему с нуля

Проект относится к библиотеке/пакету и фокусируется на архитектурной переработке существующего функционала для повышения качества и поддерживаемости.

## Success Criteria

### User Success

- Основные пользователи — наши же микросервисы.
- Пользовательский успех = микросервис подключает новую версию библиотеки через тот же `DataStoreInterface` и **не замечает разницы**: код работает без изменений и с тем же поведением.
- Ключевой показатель: совместимость интерфейса и отсутствие регрессий при интеграции.

### Business Success

- Освоить BMad‑подход: научиться работать с BMad, писать кастомных агентов и собственные воркфлоу.
- Переписать библиотеку с опорой на эти знания и лучшие практики (DDD + Clean Architecture).

### Technical Success

- Полный rewrite с нуля на DDD + Clean Architecture.
- `DataStoreInterface` сохранён для обратной совместимости.
- Полное покрытие тестами: **каждый модуль** имеет тесты.
- Архитектура обеспечивает расширяемость и стабильность для будущих datastore‑реализаций.

### Measurable Outcomes

- Новый релиз интегрируется в существующие микросервисы **без изменений кода** (интерфейс и поведение совместимы).
- MVP реализует только `read` для `MemoryDataStore`, но с корректной архитектурной структурой.
- Все модули имеют тестовое покрытие (unit/functional по необходимости).

## Product Scope

### MVP - Minimum Viable Product

- Полный каркас DDD + Clean Architecture.
- Сохранённый `DataStoreInterface`.
- Реализация **только** `read` для `MemoryDataStore`.
- Тесты для всех модулей каркаса.

### Growth Features (Post-MVP)

- `update` методы.
- Аспекты (aspects).
- Дополнительные datastore‑типы.

### Vision (Future)

- Полностью готовая библиотека для продакшена.
- Все типы DataStore и аспекты реализованы.
- Полная обратная совместимость с текущим кодом.

## User Journeys

### Journey 1: Разработчик микросервиса — «Тихое обновление»
Илья поддерживает пару микросервисов, которые используют `rollun-datastore` через `DataStoreInterface`. Он слышит, что библиотеку переписали на DDD + Clean Architecture, но для него главное — чтобы ничего не сломалось. Он обновляет зависимость в сервисе и запускает тесты. Все проверки проходят, компиляция и интеграционные тесты зелёные.

Дальше он прогоняет типовые RQL‑запросы и убеждается, что типизация работает корректно, а двойного кодирования через браузер больше нет. На проде всё стабильно: поведение интерфейса идентичное, регрессий нет. Илья считает задачу успешной — библиотека обновилась «тихо», без изменения кода микросервиса.

**Требования из journey:** обратная совместимость `DataStoreInterface`, стабильные RQL‑запросы без double‑encoding, корректная типизация, отсутствие регрессий.

### Journey 2: Разработчик микросервиса — «Подозрительная ошибка»
Илья обновляет библиотеку в тестовом окружении и видит, что один из запросов RQL возвращает неожиданные данные. Он проверяет encoding и типы, находит граничный случай, где раньше поведение было неявно корректным. Благодаря полной тестовой базе по модулям и изоляции доменных слоёв, он быстро локализует проблему: модуль RQL‑обработки.

Исправление проходит в отдельном модуле без касания других частей системы, после чего тесты снова зелёные. Он уверен, что прод не пострадает. Библиотека остаётся совместимой, а баги становятся управляемыми.

**Требования из journey:** модульная изоляция, полное тестовое покрытие, быстрая локализация ошибок, стабильное поведение при исправлениях.

### Journey Requirements Summary

- Обратная совместимость по `DataStoreInterface`
- Корректная типизация RQL и отсутствие двойного кодирования
- Полная тестовая база по каждому модулю
- Изоляция модулей для безопасных исправлений
- Отсутствие регрессий при обновлении

## Developer Tool Specific Requirements

### Project-Type Overview

Проект — PHP‑библиотека (developer tool), распространяемая через Composer. Основной фокус — обратная совместимость, читаемая документация и примеры использования для RQL/CRUD.

### Technical Architecture Considerations

- Архитектура: DDD + Clean Architecture, модульное разделение.
- Обратная совместимость с текущим `DataStoreInterface`.
- Полное тестовое покрытие модулей.

### Language Matrix

- Поддерживается **только PHP**.

### Installation Methods

- Единственный способ установки: **Composer**.

### API Surface

- Сохраняется текущий публичный интерфейс (`DataStoreInterface`), чтобы существующий код работал без изменений.
- Новая реализация должна повторять поведение на уровне контрактов и RQL‑операций.

### Code Examples

- Минимальные примеры по:
  - `read` через RQL
  - `update` через RQL
- Формат: короткие, рабочие, без лишнего окружения.

### Migration Guide

- Краткое руководство по обновлению: “обновить версию Composer → тесты зелёные → RQL работает без double‑encoding”.
- Явно подчеркнуть сохранённый интерфейс и отсутствие необходимости менять код микросервисов.

### Implementation Considerations

- Документация — минимальная, читаемая “человеком”, без перегруза.
- Примеры должны совпадать с реальным поведением библиотеки.

## Project Scoping & Phased Development

### MVP Strategy & Philosophy

**MVP Approach:** Problem‑Solving + Platform  
**Resource Requirements:** 1 разработчик + LLM

### MVP Feature Set (Phase 1)

**Core User Journeys Supported:**
- Разработчик микросервиса обновляет библиотеку без изменения кода и без регрессий.

**Must-Have Capabilities:**
- Архитектурный каркас DDD + Clean Architecture.
- Сохранённый `DataStoreInterface`.
- Реализация `read` только для `MemoryDataStore`.
- Исправлены критичные проблемы: типизация RQL, double‑encoding.
- Полное тестовое покрытие модулей.

### Post-MVP Features

**Phase 2 (Post-MVP):**
- Методы `update`.
- Аспекты (aspects).
- Дополнительные datastore‑типы.

**Phase 3 (Expansion):**
- Полный набор DataStore и аспектов.
- Production‑готовая библиотека.

### Risk Mitigation Strategy

**Technical Risks:** существенных рисков не выявлено  
**Market Risks:** «не стало лучше» = если баги типизации/RQL и double‑encoding сохраняются  
**Resource Risks:** время найдём, допускается более длинный цикл

## Functional Requirements

### Обратная совместимость

- FR1: Микросервис может использовать `DataStoreInterface` без изменения существующего кода.
- FR2: Микросервис получает то же поведение интерфейса, что и в текущей версии библиотеки.
- FR3: Обновление библиотеки не требует изменения контрактов интеграции.

### RQL‑запросы и типизация

- FR4: Система корректно обрабатывает RQL‑запросы без двойного кодирования.
- FR5: Система корректно интерпретирует типы в RQL‑значениях (string/integer/float/boolean).
- FR6: Поведение RQL‑фильтрации совпадает с текущими ожиданиями пользователей библиотеки.

### MVP: MemoryDataStore (read)

- FR7: Пользователь может читать данные из `MemoryDataStore` через `read`.
- FR8: `read` поддерживает RQL‑фильтрацию согласно текущему контракту.

### Архитектурный каркас

- FR9: Система предоставляет модульную структуру с четкими границами домена.
- FR10: Каждый модуль может развиваться независимо без влияния на внешний контракт.

### Тестирование

- FR11: Каждый модуль имеет тесты, покрывающие ключевые сценарии поведения.
- FR12: Тестовый набор позволяет выявлять регрессии в RQL и совместимости интерфейса.

### Документация и примеры

- FR13: Пользователь получает минимальную документацию для работы с библиотекой.
- FR14: Документация содержит примеры `read` и `update` с использованием RQL.

### Миграция/обновление

- FR15: Документация содержит краткую инструкцию по обновлению библиотеки без изменений кода.
- FR16: Процесс обновления описывает проверку корректности (например, тесты и примеры запросов).

## Non-Functional Requirements

### Reliability

- Отсутствие регрессий в RQL (парсинг, типизация, поведение фильтров).
- Стабильное поведение `DataStoreInterface` при обновлении версии библиотеки.

### Integration

- Полная обратная совместимость интерфейса для существующих микросервисов.
- Обновление библиотеки не требует изменения кода потребителей.

### Scalability

- Специальных требований нет; архитектура должна **подразумевать** масштабируемость без принудительных ограничений.
