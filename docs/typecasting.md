## Пошук з приведенням типів

У RQL значення можна (і бажано) вказувати з **підказкою типу**. Це робить порівняння однозначним і допомагає уникати неочікуваних перетворень.
Наприклад:
- `eq(id,108693)` — порівняння з **числом** `108693`.
- `eq(id,string:108693)` — порівняння зі **рядком** `"108693"`.

> [!NOTE]
> Підказки типу (`string:`, `integer:`, `float:`, `boolean:`) застосовуються **під час парсингу RQL**. Тобто датастор отримує вже **типізоване PHP-значення**. Якщо тип колонки у БД відрізняється від типу значення, MySQL може виконати **додаткове** приведення типів під час виконання запиту.

---

Це важливо, тому що результати пошуку можуть відрізнятись в залежності від того, як датастор працює з приведенням типів.
Треба розуміти, що зазвичай датастор зберігає типізованні дані. Наприклад поле `id` може зберігатись як рядок, або як
число. І якщо в rql буде вказаний інший тип, ніж той під яким значення зберігається в датасторі, то буде відбуватись
приведення типів до одного.

## Як це працює

1. **Lexer** лише розбиває вхідний рядок на токени і **не** виконує приведення типів.
2. **ValueParser** розпізнає префікси типів і викликає відповідний кастер:
    - `string:<value>` → рядок,
    - `integer:<value>` → ціле число,
    - `float:<value>` → число з плаваючою крапкою,
    - `boolean:<value>` → `true`/`false` (наприклад, `boolean:1` → `true`, `boolean:0` → `false`).
3. Парсери операторів (`eq`, `ne`, `lt`, `in`, …) отримують **вже типізовані** значення.

> [!TIP]
> Найкраща практика — **узгоджувати тип у RQL із типом колонки в БД**. Числові колонки — шукати числом, текстові — рядком. Так ви уникнете зайвих приведень та отримаєте стабільне використання індексів.

---

## Приклади (DbTable з MySQL)

1. `eq(id,108693)`  
   Якщо `id` — **рядкова** колонка (`VARCHAR`), MySQL приведе **значення колонки** до числа і порівняє з `108693`.

2. `eq(id,string:108693)`  
   Якщо `id` — **числова** колонка (`INT`), MySQL приведе **аргумент запиту** `'108693'` до числа `108693` і порівняє.

> [!WARNING]
> Ведучі нулі: якщо `id` — рядок, то `eq(id,string:108693)` **не** знайде запис із `id = "0108693"`.  
> А `eq(id,108693)` знайде — бо `"0108693"` у числовому контексті перетвориться на `108693`.

## Неочікувані ефекти перетворень у MySQL

У **числовому контексті** MySQL читає рядок **до першого нецифрового символу**:
- `'1abc'` → **1**
- `'abc'` → **0**
- `'00'` → **0**
- `'0108693'` → **108693**

Отже, `eq(id,string:1abc)` для числової колонки `id` скоріше знайде записи з `id = 1`, а не з 0.

- Якщо тип колонки в таблиці - число, а ми шукаємо збіг з рядком "1abc" (`eq(id,string:1abc)`), то, MySQL буде
  перетворювати рядок "1abc" в число, а оскільки "1abc" не є числом, то воно перетвориться в число нуль. Тому в
  результаті пошуку `eq(id,string:1abc)` повернуться усі записи у яких `{"id": 0}`
- І навпаки, якщо тип колонки - рядок, а ми шукаємо збіг з числом нуль `eq(id,0)`, то повернуться усі записи
  значення яких неможливо однозначно привести до числа. Наприклад `[{“id”:”00”}, {“id”:”bar”}]
- Проблема з нулями на початку. Якщо тип колонки id - рядок, то запит `eq(id,(string:108693))` - не поверне запис 
  у якого id = "0108693" (нуль на початку). При цьому пошук з числом `eq(id,108693)` - поверне цей запис (так как 
  "0108693" перетвориться в число і після цього виконається порівняння)

> [!TIP]
> Найкращим варіантом буде виконувати пошук з тим значенням з яким колонка зберігається в датасторі. Числа шукати як 
> числа, а рядки як рядки, щоб не було приведення типів.
